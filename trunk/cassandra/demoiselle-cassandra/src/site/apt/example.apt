~~Demoiselle Framework
~~Copyright (c) 2010 SERPRO and other contributors as indicated by the @author tag.
~~
~~Demoiselle Framework is an open source Java EE library designed to accelerate
~~the development of transactional database Web applications.
~~
~~Demoiselle Framework is released under the terms of the LGPL license 3
~~http://www.gnu.org/licenses/lgpl.html  LGPL License 3
~~
~~This file is part of Demoiselle Framework.
~~
~~Demoiselle Framework is free software: you can redistribute it and/or modify
~~it under the terms of the GNU Lesser General Public License 3 as published by
~~the Free Software Foundation.
~~
~~Demoiselle Framework is distributed in the hope that it will be useful,
~~but WITHOUT ANY WARRANTY; without even the implied warranty of
~~MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
~~GNU Lesser General Public License for more details.
~~
~~You should have received a copy of the GNU Lesser General Public License
~~along with Demoiselle Framework.  If not, see <http://www.gnu.org/licenses/>.
  
                                    ------
                                    Exemplo de Uso
                                    
Exemplo de Uso

%{toc|section=1|fromDepth=1|toDepth=3}

* {Modelo de dados}

  ...
  
[images/twitter-model1.png] Modelo de dados 1
  
  ...

[images/twitter-model2.png] Modelo de dados 2
  
  ...


* {Persistência de entidade simples}

   * {Criação da entidade <<<User>>>}

   * Crie a classe correspondente à entidade com as devidas anotações da JPA:
   
+---------------------------------------------------------------------------------------------+  
@CassandraEntity(keyspace = "Twitter", columnFamily = "Users")
public class User {

	@KeyProperty
	private String login;
	
	private String name;
	private String password;

	...
}
+---------------------------------------------------------------------------------------------+
  
   ** {Criação da interface <<<IUserDAO>>>}

   * Estendendo a interface CassandraDAO, crie a interface correspondente à DAO que manipulará a entidade:

+---------------------------------------------------------------------------------------------+  
public interface IUserDAO extends CassandraDAO<User> {

	User findByLogin(String login);

	List<User> findByLogins(Iterable<String> logins);

}
+---------------------------------------------------------------------------------------------+

   ** {Criação da classe <<<UserDAO>>>}

   * Estendendo a classe JPAExtensionDAO e implementando a interface anterior, crie a classe contendo a implementação da DAO:
 
+---------------------------------------------------------------------------------------------+   
public class UserDAO extends CassandraEntityDAO<User> implements IUserDAO {
	
	public User findByLogin(String login) {
		return get(login);
	}

	public List<User> findByLogins(Iterable<String> logins) {
		return get(logins);
	}

}
+---------------------------------------------------------------------------------------------+        

   ** {hfjkgh lksjdfghl skdf}

   * ....:
 
+---------------------------------------------------------------------------------------------+   
public class TwitterFacade extends IFacade {

	@Injection
	private IUserDAO userDAO;

	public User createUser(String login, String name, String password) {
		
		User user = new User();
		user.setLogin(login);
		user.setName(name);
		user.setPassword(password);
		
		userDAO.save(user);
		
		return user;
	}

	public void removeUser(String login) {
		userDAO.delete(new User(login));
	}

	public User findUserByLogin(String login) {
		return userDAO.findByLogin(login);
	}

}
+---------------------------------------------------------------------------------------------+        


* {Persistência de coluna}

   ...

   * {Criação da entidade <<<Followship>>>}

   * Crie a classe correspondente à entidade com as devidas anotações da JPA:
   
+---------------------------------------------------------------------------------------------+  
@CassandraColumn(keyspace = "Twitter", columnFamily = "Following",
		secondaryColumnFamily = "Followers")
public class Followship {

	@KeyProperty
	private String follower;

	@ColumnProperty
	private String followed;

	...
}
+---------------------------------------------------------------------------------------------+
  
   ** {Criação da interface <<<IUserDAO>>>}

   * Estendendo a interface CassandraDAO, crie a interface correspondente à DAO que manipulará a entidade:

+---------------------------------------------------------------------------------------------+  
public interface IFollowshipDAO extends CassandraDAO<Followship> {

	List<String> findFollowingsLogins(String follower);

	List<String> findFollowersLogins(String followed);

}
+---------------------------------------------------------------------------------------------+

   ** {Criação da classe <<<UserDAO>>>}

   * Estendendo a classe JPAExtensionDAO e implementando a interface anterior, crie a classe contendo a implementação da DAO:
 
+---------------------------------------------------------------------------------------------+   
public class FollowshipDAO extends CassandraColumnDAO<Followship>
		implements IFollowshipDAO {

	public List<String> findFollowingsLogins(String follower) {
		return getColumns(follower);
	}

	public List<String> findFollowersLogins(String followed) {
		return getColumnsBySecondary(followed);
	}

}
+---------------------------------------------------------------------------------------------+        

   ** {hfjkgh lksjdfghl skdf}

   * ....:
 
+---------------------------------------------------------------------------------------------+   
public class TwitterFacade extends IFacade {

	...
    
	@Injection
	private IFollowshipDAO followshipDAO;
    
	...
    
	public Followship followUser(String login, String followed) {

		Followship followship = new Followship();
		followship.setFollower(login);
		followship.setFollowed(followed);
		
		followshipDAO.save(followship);

		return followship;
	}

	public void unfollowUser(String login, String followed) {

		Followship followship = new Followship();
		followship.setFollower(login);
		followship.setFollowed(followed);
		
		followshipDAO.delete(followship);
	}

	public List<User> findUserFollowings(String login) {
		
		List<String> ids = followshipDAO.findFollowingsLogins(login);
		
		if (ids == null || ids.isEmpty())
			return null;
		
		List<User> users = userDAO.findByLogins(ids);
		
		return users;
	}

	public List<User> findUserFollowers(String login) {
		
		List<String> ids = followshipDAO.findFollowersLogins(login);

		if (ids == null || ids.isEmpty())
			return null;
		
		List<User> users = userDAO.findByLogins(ids);
		
		return users;
	}

}

+---------------------------------------------------------------------------------------------+        
   
* {Persistência de entidade simples ...}

   * {Criação da entidade <<<User>>>}

   * Crie a classe correspondente à entidade com as devidas anotações da JPA:
   
+---------------------------------------------------------------------------------------------+  
@CassandraEntity(keyspace = "Twitter", columnFamily = "Tweets")
public class Tweet {

	@KeyProperty
	private Long id;
	
	private String user;
	private String text;

	...
}
+---------------------------------------------------------------------------------------------+

   * Crie a classe ...
   
+---------------------------------------------------------------------------------------------+  
@CassandraColumn(keyspace = "Twitter", columnFamily = "Userline")
public class UserLine implements TweetLine {

	@KeyProperty
	private String user;
	
	@ColumnProperty
	private Long time;
	
	@ValueProperty
	private Long tweet;
	
	...
}
+---------------------------------------------------------------------------------------------+

   * Crie a classe ...
   
+---------------------------------------------------------------------------------------------+  
@CassandraColumn(keyspace = "Twitter", columnFamily = "Timeline")
public class TimeLine implements TweetLine {

	@KeyProperty
	private String user;

	@ColumnProperty
	private Long time;
	
	@ValueProperty
	private Long tweet;

	...
}
+---------------------------------------------------------------------------------------------+
  
   ** {Criação da interface <<<IUserDAO>>>}

   * Estendendo a interface CassandraDAO, crie a interface correspondente à DAO que manipulará a entidade:

+---------------------------------------------------------------------------------------------+  
public interface ITweetDAO extends CassandraDAO<Tweet> {

	Tweet findById(Long id);

	List<Tweet> findByIds(Iterable<Long> ids);

}
+---------------------------------------------------------------------------------------------+

   * Estendendo a interface CassandraDAO, crie a interface correspondente à DAO que manipulará a entidade:

+---------------------------------------------------------------------------------------------+  
public interface IUserLineDAO extends CassandraDAO<UserLine> {

	List<Long> findUserLine(String user);

}
+---------------------------------------------------------------------------------------------+  

   * Estendendo a interface CassandraDAO, crie a interface correspondente à DAO que manipulará a entidade:

+---------------------------------------------------------------------------------------------+  
public interface ITimeLineDAO extends CassandraDAO<TimeLine> {
	
	List<Long> findTimeLine(String user);

}
+---------------------------------------------------------------------------------------------+  

   ** {Criação da classe <<<UserDAO>>>}

   * Estendendo a classe JPAExtensionDAO e implementando a interface anterior, crie a classe contendo a implementação da DAO:
 
+---------------------------------------------------------------------------------------------+   
public class TweetDAO extends CassandraEntityDAO<Tweet> implements ITweetDAO {

	public Tweet findById(Long id) {
		return get(id.toString());
	}

	public List<Tweet> findByIds(Iterable<Long> ids) {
		return get(Iterables.transform(ids, Functions.toStringFunction()));
	}

}
+---------------------------------------------------------------------------------------------+        

   * Estendendo a classe JPAExtensionDAO e implementando a interface anterior, crie a classe contendo a implementação da DAO:
 
+---------------------------------------------------------------------------------------------+   
public class UserLineDAO extends CassandraColumnDAO<UserLine> implements IUserLineDAO {

	public List<Long> findUserLine(String user) {
		
		List<String> values = getValues(user);
		
		if (values == null || values.isEmpty())
			return null;
		
		List<Long> tweets = Lists.transform(values, new Function<String, Long>() {
			public Long apply(String from) {
				return Long.parseLong(from);
			}
		});
		
		return tweets;
	}

}
+---------------------------------------------------------------------------------------------+        

   * Estendendo a classe JPAExtensionDAO e implementando a interface anterior, crie a classe contendo a implementação da DAO:
 
+---------------------------------------------------------------------------------------------+   
public class TimeLineDAO extends CassandraColumnDAO<TimeLine> implements ITimeLineDAO {

	public List<Long> findTimeLine(String user) {
		
		List<String> values = getValues(user);
		
		if (values == null || values.isEmpty())
			return null;
		
		List<Long> tweets = Lists.transform(values, new Function<String, Long>() {
			public Long apply(String from) {
				return Long.parseLong(from);
			}
		});
		
		return tweets;
	}

}
+---------------------------------------------------------------------------------------------+        

   ** {hfjkgh lksjdfghl skdf}

   * ....:
 
+---------------------------------------------------------------------------------------------+   
public class TwitterFacade extends IFacade {

	...
    
	@Injection
	private ITweetDAO tweetDAO;
	
	@Injection
	private IUserLineDAO userlineDAO;
	
	@Injection
	private ITimeLineDAO timelineDAO;
    
	...

	public Tweet postTweet(String login, String text) {

		final long id = (long) (Math.random() * 1E10);

		Tweet tweet = new Tweet();
		tweet.setId(id);
		tweet.setUser(login);
		tweet.setText(text);
		
		tweetDAO.save(tweet);
		
		final long timestamp = System.currentTimeMillis();

		UserLine userline = new UserLine();
		userline.setUser(login);
		userline.setTime(timestamp);
		userline.setTweet(id);
		userlineDAO.save(userline);

		List<String> logins = followshipDAO.findFollowersLogins(login);
		if (logins != null) {
			TimeLine timeline = null;
			for (String follower : logins) {
				timeline = new TimeLine();
				timeline.setUser(follower);
				timeline.setTime(timestamp);
				timeline.setTweet(id);
				timelineDAO.save(timeline);
			}
		}

		return tweet;
	}

	public void removeTweet(Long id) {
		Tweet tweet = tweetDAO.findById(id);
		tweetDAO.delete(tweet);
	}

	public Tweet findTweet(Long id) {
		Tweet tweet = tweetDAO.findById(id);
		return tweet;
	}

	public List<Tweet> findUserLastTweets(String login, int count) {

		List<Long> ids1 = userlineDAO.findUserLine(login);
		List<Long> ids2 = timelineDAO.findTimeLine(login);
		
		List<Long> ids = new ArrayList<Long>();
		if (ids1 != null)
			ids.addAll(ids1);
		if (ids2 != null)
			ids.addAll(ids2);
		
		if (ids == null || ids.isEmpty())
			return null;
		
		List<Tweet> tweets = tweetDAO.findByIds(ids);

		// TODO: ordernar pelo timestamp e limitar a quantidade de ocorrências (count)
		
		return tweets;
	}

	public List<Tweet> findUserLastTweets(String login) {
		return findUserLastTweets(login, TWEETS_DEFAULT_COUNT);
	}
	
}
+---------------------------------------------------------------------------------------------+        
